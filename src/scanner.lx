%option noyywrap nodefault nounput yylineno

%{
#include <string>
#include <vector>
#include <stdexcept>
#include "tokens.hpp"
#include <cstdio>

// Match Flex-generated declarations (C++ linkage) DO NOT EDIT

typedef struct yy_buffer_state *YY_BUFFER_STATE;
int yylex(void);
void yyrestart(FILE*);
YY_BUFFER_STATE yy_scan_string(const char* str);
void yy_delete_buffer(YY_BUFFER_STATE b);

static std::vector<Token>* g_tokens = nullptr;
static YY_BUFFER_STATE g_buf = nullptr;

void scan_to_tokens(std::vector<Token>& out) {
    g_tokens = &out;
    yyrestart(nullptr);
    yylex();
}

void scan_string_to_tokens(const std::string& src, std::vector<Token>& out) {
    g_tokens = &out;
    g_buf = yy_scan_string(src.c_str());
    yylex();
    yy_delete_buffer(g_buf);
    g_buf = nullptr;
}

%}

DIGIT      [0-9]
ID_START   [A-Za-z_]
ID_CONT    [A-Za-z0-9_]
WS         [ \t\r\f]+
NL         [\n]

%%

"#"[^\n]*                ;   // Comment

"=="        { g_tokens->push_back(Token{TokenType::Equal, yytext, yylineno}); }
"!="        { g_tokens->push_back(Token{TokenType::NotEqual, yytext, yylineno}); }
"<="        { g_tokens->push_back(Token{TokenType::LessEq, yytext, yylineno}); }
">="        { g_tokens->push_back(Token{TokenType::GreaterEq, yytext, yylineno}); }

"&&"        { g_tokens->push_back(Token{TokenType::And, yytext, yylineno}); }
"||"        { g_tokens->push_back(Token{TokenType::Or, yytext, yylineno}); }
"!"         { g_tokens->push_back(Token{TokenType::Not, yytext, yylineno}); }
"<"         { g_tokens->push_back(Token{TokenType::Less, yytext, yylineno}); }
">"         { g_tokens->push_back(Token{TokenType::Greater, yytext, yylineno}); }

";"         { g_tokens->push_back(Token{TokenType::Semicolon, yytext, yylineno}); }
","         { g_tokens->push_back(Token{TokenType::Comma, yytext, yylineno}); }
"("         { g_tokens->push_back(Token{TokenType::LParen, yytext, yylineno}); }
")"         { g_tokens->push_back(Token{TokenType::RParen, yytext, yylineno}); }    
"{"         { g_tokens->push_back(Token{TokenType::LBrace, yytext, yylineno}); }
"}"         { g_tokens->push_back(Token{TokenType::RBrace, yytext, yylineno}); }
"="         { g_tokens->push_back(Token{TokenType::Assign, yytext, yylineno}); }

{ID_START}{ID_CONT}*     {
    std::string s(yytext, yyleng);
    if      (s == "if")     g_tokens->push_back(Token{TokenType::If, s, yylineno});
    else if (s == "else")   g_tokens->push_back(Token{TokenType::Else, s, yylineno});
    else if (s == "while")  g_tokens->push_back(Token{TokenType::While, s, yylineno});
    else if (s == "cout")  g_tokens->push_back(Token{TokenType::Print, s, yylineno});
    else                    g_tokens->push_back(Token{TokenType::Var, "V" + s, yylineno});
}

\"([^\"\\]|\\.)*\"       {
    std::string s(yytext + 1, yyleng - 2);
    g_tokens->push_back(Token{TokenType::String, s, yylineno});
}

{DIGIT}+                 {
    g_tokens->push_back(Token{TokenType::IntLit,
                              std::string(yytext, yyleng), yylineno});
}

{WS}                     ;   // Ignore whitespace
{NL}                     ;   // Ignore newlines

.                        {
    throw std::runtime_error("Unknown char at line " +
                             std::to_string(yylineno));
}

<<EOF>>                  {
    g_tokens->push_back(Token{TokenType::End, "END", yylineno});
    return 0;
}

%%
